<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chain Lightning 3D Combo Explorer</title>
  <style>
    :root {
      --bg: #0a1b33;
      --panel: #0d213d;
      --ink: #e9f1ff;
      --muted: #9ab1d5;
      --line: #27466f;
      --accent: #4aa1d3;
      --accent2: #dc768b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      color: var(--ink);
      background: var(--bg);
    }
    .app {
      display: grid;
      grid-template-columns: 1.3fr 420px;
      min-height: 100vh;
      gap: 14px;
      padding: 14px;
    }
    .plot-wrap, .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(20, 35, 60, 0.08);
    }
    .plot-wrap {
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      --legend-top: 62px;
      --legend-height: 180px;
    }
    .plot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      border-bottom: 1px solid var(--line);
      gap: 12px;
    }
    .plot-title {
      font-size: 17px;
      font-weight: 700;
    }
    .hint {
      color: var(--muted);
      font-size: 12px;
    }
    #viewport {
      width: 100%;
      height: calc(100vh - 98px);
      cursor: grab;
      background: #0a1b33;
      touch-action: none;
    }
    #viewport.dragging {
      cursor: grabbing;
    }
    .legend {
      position: absolute;
      right: 14px;
      top: var(--legend-top);
      width: 18px;
      height: var(--legend-height);
      border: 1px solid #00000022;
      background: linear-gradient(to top, #3a78a5, #96c9a5, #ece8b0, #eaa366, #c94e4c);
    }
    .legend-label {
      position: absolute;
      right: 40px;
      font-size: 11px;
      color: var(--muted);
      background: #0f1f35cc;
      padding: 1px 4px;
      border-radius: 4px;
      border: 1px solid #bcd2f322;
    }
    #legendTop { top: calc(var(--legend-top) - 2px); }
    #legendBottom { top: calc(var(--legend-top) + var(--legend-height) - 2px); }
    #legendName {
      top: calc(var(--legend-top) - 22px);
      right: 14px;
      font-weight: 600;
      color: var(--ink);
      background: none;
      border: none;
      padding: 0;
    }
    .tooltip {
      position: absolute;
      pointer-events: none;
      min-width: 180px;
      max-width: 260px;
      background: #0e1726e6;
      color: #f0f5ff;
      border: 1px solid #ffffff2d;
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.35;
      display: none;
      z-index: 3;
      backdrop-filter: blur(2px);
    }
    .panel {
      padding: 14px;
      overflow: auto;
      max-height: calc(100vh - 28px);
    }
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
    }
    .panel h2 {
      margin: 0;
      font-size: 17px;
    }
    #toggleControls {
      width: 36px;
      min-width: 36px;
      height: 32px;
      padding: 0;
      font-size: 16px;
      line-height: 1;
    }
    .panel-content {
      display: block;
    }
    .app.controls-collapsed {
      grid-template-columns: 1fr 58px;
    }
    .app.controls-collapsed .panel {
      padding: 10px;
      overflow: hidden;
    }
    .app.controls-collapsed .panel h2,
    .app.controls-collapsed .panel-content {
      display: none;
    }
    .app.controls-collapsed .panel-header {
      justify-content: center;
      margin-bottom: 0;
    }
    .app.controls-collapsed #toggleControls {
      width: 34px;
      min-width: 34px;
    }
    .group {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .group h3 {
      margin: 0 0 8px;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
    }
    .row {
      display: grid;
      grid-template-columns: 106px 1fr;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }
    label { font-size: 12px; color: var(--muted); }
    select, input[type="number"], button {
      width: 100%;
      padding: 7px 8px;
      border: 1px solid var(--line);
      border-radius: 7px;
      font-size: 13px;
      color: var(--ink);
      background: #0d1f37;
    }
    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    .check-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 6px;
      font-size: 13px;
    }
    .check-row input {
      width: 15px;
      height: 15px;
      accent-color: var(--accent2);
    }
    .btn-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 6px;
    }
    button {
      cursor: pointer;
      font-weight: 600;
    }
    button:hover {
      border-color: #5e88b5;
      background: #153150;
    }
    .stats {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
      margin-top: 6px;
      white-space: pre-wrap;
      font-variant-numeric: tabular-nums;
    }
    .compare-help {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 99px;
      margin-right: 6px;
      vertical-align: middle;
    }
    .swatch-a { background: #f97316; }
    .swatch-b { background: #7c3aed; }
    .swatch-path { background: #0f766e; }
    .path-steps {
      max-height: 250px;
      overflow: auto;
      white-space: pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      line-height: 1.35;
      background: #0e2139;
      border: 1px solid #2b4a72;
      border-radius: 8px;
      padding: 8px;
      margin-top: 8px;
    }
    @media (max-width: 1100px) {
      .app { grid-template-columns: 1fr; }
      #viewport { height: 62vh; }
      .panel { max-height: unset; }
      .legend {
        right: 10px;
        width: 14px;
      }
      .legend-label {
        right: 30px;
      }
      #legendName {
        right: 10px;
      }
      .app.controls-collapsed { grid-template-columns: 1fr; }
      .app.controls-collapsed .panel h2,
      .app.controls-collapsed .panel-content {
        display: block;
      }
      .app.controls-collapsed .panel-header {
        justify-content: space-between;
        margin-bottom: 10px;
      }
      .app.controls-collapsed #toggleControls {
        width: 36px;
        min-width: 36px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="plot-wrap">
      <div class="plot-header">
        <div>
          <div class="plot-title">Chain Lightning 3D Combination Explorer</div>
          <div class="hint">Drag to rotate, wheel/pinch to zoom, Shift or two-finger drag to pan</div>
        </div>
        <div class="hint" id="countLabel">0 / 0 points</div>
      </div>
      <canvas id="viewport"></canvas>
      <div class="legend" id="legendBar"></div>
      <div class="legend-label" id="legendName">Color</div>
      <div class="legend-label" id="legendTop">max</div>
      <div class="legend-label" id="legendBottom">min</div>
      <div class="tooltip" id="tooltip"></div>
    </div>

    <div class="panel">
      <div class="panel-header">
        <h2>Controls</h2>
        <button id="toggleControls" title="Collapse controls" aria-label="Collapse controls">&lsaquo;</button>
      </div>
      <div class="panel-content">

      <div class="group">
        <h3>Axis Mapping</h3>
        <div class="row"><label for="xAxis">X Axis</label><select id="xAxis"></select></div>
        <div class="row"><label for="yAxis">Y Axis</label><select id="yAxis"></select></div>
        <div class="row"><label for="zAxis">Z Axis</label><select id="zAxis"></select></div>
      </div>

      <div class="group">
        <h3>Visual Encoding</h3>
        <div class="row"><label for="sizeBy">Size By</label><select id="sizeBy"></select></div>
        <div class="row"><label for="colorBy">Color By</label><select id="colorBy"></select></div>
        <div class="check-row"><input id="showPareto" type="checkbox" checked /><label for="showPareto">Outline Best Value points</label></div>
        <div class="check-row"><input id="onlyPareto" type="checkbox" /><label for="onlyPareto">Show only Best Value points</label></div>
      </div>

      <div class="group">
        <h3>Filters</h3>
        <div class="row"><label for="costMin">Cost Min</label><input id="costMin" type="number" step="1" /></div>
        <div class="row"><label for="costMax">Cost Max</label><input id="costMax" type="number" step="1" /></div>
        <div class="row"><label>Cost Range</label><div><input id="costMinRange" type="range" /><input id="costMaxRange" type="range" /></div></div>
        <div class="row"><label for="prodMin">Effective Damage Min</label><input id="prodMin" type="number" step="0.01" /></div>
        <div class="row"><label for="prodMax">Effective Damage Max</label><input id="prodMax" type="number" step="0.01" /></div>
        <div class="row"><label>Effective Damage Range</label><div><input id="prodMinRange" type="range" /><input id="prodMaxRange" type="range" /></div></div>
      </div>

      <div class="group">
        <h3>View</h3>
        <div class="btn-row">
          <button id="resetView">Reset Camera</button>
          <button id="resetFilters">Reset Filters</button>
        </div>
        <div class="stats" id="stats"></div>
      </div>

      <div class="group">
        <h3>Compare</h3>
        <div class="compare-help">Click circles in the chart to select two points for comparison.</div>
        <div class="compare-help"><span class="swatch swatch-a"></span>A selection <span class="swatch swatch-b" style="margin-left:10px;"></span>B selection</div>
        <div class="btn-row">
          <button id="swapCompare">Swap A/B</button>
          <button id="clearCompare">Clear Compare</button>
        </div>
        <div class="stats" id="compareStats">Select point A, then point B.</div>
      </div>

      <div class="group">
        <h3>Most Efficient Path</h3>
        <div class="compare-help">Greedy route: each step buys the upgrade with highest Effective Damage gain per cost.</div>
        <div class="check-row"><input id="showPathLine" type="checkbox" checked /><label for="showPathLine"><span class="swatch swatch-path"></span>Show efficient path line</label></div>
        <div class="check-row"><input id="showPathPoints" type="checkbox" checked /><label for="showPathPoints">Show efficient path points</label></div>
        <div class="stats" id="pathSummary"></div>
        <div class="path-steps" id="pathSteps"></div>
      </div>
      </div>
    </div>
  </div>

  <script>
    // Source levels from Tower Stats - Chain Lightning.csv
    const damageVals = [2,3,5,9,14,22,32,46,63,85,113,148,191,244,309,387,482,596,733,898,1094,1328,1607,1937,2329,2794,3342,3990,4755,5655,6715,7961];
    const damageCosts = [0,5,11,17,23,29,35,41,47,53,61,71,84,100,120,144,174,210,252,302,362,434,525,636,767,923,1109,1295,1521,1787,2103,2469];
    const quantityVals = [1,2,3,4,5];
    const quantityCosts = [0,30,75,150,400];
    const chanceVals = [5,6.5,8,9.5,11,12.5,14,15.5,17,18.5,20,21.5,23,24.5,26,27.5];
    const chanceCosts = [0,8,26,44,62,80,98,116,134,152,170,188,206,224,242,260];

    function cumulative(arr) {
      let sum = 0;
      return arr.map((v) => (sum += v));
    }

    function buildCombos() {
      const dCum = cumulative(damageCosts);
      const qCum = cumulative(quantityCosts);
      const cCum = cumulative(chanceCosts);
      const out = [];
      for (let di = 0; di < damageVals.length; di++) {
        for (let qi = 0; qi < quantityVals.length; qi++) {
          for (let ci = 0; ci < chanceVals.length; ci++) {
            const damage = damageVals[di];
            const quantity = quantityVals[qi];
            const chance = chanceVals[ci];
            const product = damage * quantity * (chance / 100.0);
            const totalCost = dCum[di] + qCum[qi] + cCum[ci];
            out.push({
              damageLevel: di + 1,
              quantityLevel: qi + 1,
              chanceLevel: ci + 1,
              damage,
              quantity,
              chance,
              totalCost,
              product,
              pareto: false
            });
          }
        }
      }

      // Best Value frontier: minimize cost, maximize effective damage.
      const sorted = [...out].sort((a, b) => {
        if (a.totalCost !== b.totalCost) return a.totalCost - b.totalCost;
        return b.product - a.product;
      });
      let best = -Infinity;
      for (const p of sorted) {
        if (p.product > best) {
          p.pareto = true;
          best = p.product;
        }
      }
      return out;
    }

    const allPoints = buildCombos();
    const dims = {
      "Chance": "chance",
      "Quantity": "quantity",
      "Damage": "damage",
      "Total Cost": "totalCost",
      "Effective Damage": "product"
    };
    const sizeDims = { ...dims, "Constant": "constant" };

    const appEl = document.querySelector(".app");
    const plotWrapEl = document.querySelector(".plot-wrap");
    const plotHeaderEl = document.querySelector(".plot-header");
    const canvas = document.getElementById("viewport");
    const ctx = canvas.getContext("2d");
    const tooltip = document.getElementById("tooltip");
    const stats = document.getElementById("stats");
    const compareStats = document.getElementById("compareStats");
    const pathSummary = document.getElementById("pathSummary");
    const pathSteps = document.getElementById("pathSteps");
    const countLabel = document.getElementById("countLabel");
    const legendName = document.getElementById("legendName");
    const legendTop = document.getElementById("legendTop");
    const legendBottom = document.getElementById("legendBottom");

    const controls = {
      xAxis: document.getElementById("xAxis"),
      yAxis: document.getElementById("yAxis"),
      zAxis: document.getElementById("zAxis"),
      sizeBy: document.getElementById("sizeBy"),
      colorBy: document.getElementById("colorBy"),
      showPareto: document.getElementById("showPareto"),
      onlyPareto: document.getElementById("onlyPareto"),
      costMin: document.getElementById("costMin"),
      costMax: document.getElementById("costMax"),
      costMinRange: document.getElementById("costMinRange"),
      costMaxRange: document.getElementById("costMaxRange"),
      prodMin: document.getElementById("prodMin"),
      prodMax: document.getElementById("prodMax"),
      prodMinRange: document.getElementById("prodMinRange"),
      prodMaxRange: document.getElementById("prodMaxRange"),
      resetView: document.getElementById("resetView"),
      resetFilters: document.getElementById("resetFilters"),
      swapCompare: document.getElementById("swapCompare"),
      clearCompare: document.getElementById("clearCompare"),
      showPathLine: document.getElementById("showPathLine"),
      showPathPoints: document.getElementById("showPathPoints"),
      toggleControls: document.getElementById("toggleControls")
    };

    const state = {
      xAxis: "Chance",
      yAxis: "Quantity",
      zAxis: "Damage",
      sizeBy: "Effective Damage",
      colorBy: "Total Cost",
      showPareto: true,
      onlyPareto: false,
      costMin: 0,
      costMax: 0,
      prodMin: 0,
      prodMax: 0,
      yaw: -0.74,
      pitch: 0.42,
      zoom: 1.42,
      panX: 0,
      panY: 0,
      selectedA: null,
      selectedB: null,
      showPathLine: true,
      showPathPoints: true,
      controlsCollapsed: false,
      autoRotate: true
    };
    let autoRotateFrame = 0;
    let autoRotateLastTs = 0;

    function setControlsCollapsed(collapsed, shouldResize = true) {
      state.controlsCollapsed = collapsed;
      appEl.classList.toggle("controls-collapsed", collapsed);
      controls.toggleControls.innerHTML = collapsed ? "&rsaquo;" : "&lsaquo;";
      controls.toggleControls.title = collapsed ? "Expand controls" : "Collapse controls";
      controls.toggleControls.setAttribute("aria-label", controls.toggleControls.title);
      try {
        localStorage.setItem("clx_controls_collapsed", collapsed ? "1" : "0");
      } catch (_err) {
        // ignore storage failures
      }
      if (shouldResize) {
        resizeCanvas();
      }
    }

    function pointKey(p) {
      return `${p.damageLevel}-${p.quantityLevel}-${p.chanceLevel}`;
    }

    function stopAutoRotate() {
      if (!state.autoRotate) return;
      state.autoRotate = false;
      if (autoRotateFrame) {
        cancelAnimationFrame(autoRotateFrame);
        autoRotateFrame = 0;
      }
      autoRotateLastTs = 0;
    }

    function startAutoRotate() {
      if (!state.autoRotate || autoRotateFrame) return;
      const step = (ts) => {
        if (!state.autoRotate) {
          autoRotateFrame = 0;
          autoRotateLastTs = 0;
          return;
        }
        if (!autoRotateLastTs) autoRotateLastTs = ts;
        const dt = Math.min(80, ts - autoRotateLastTs);
        autoRotateLastTs = ts;
        state.yaw += dt * 0.0001;
        draw();
        autoRotateFrame = requestAnimationFrame(step);
      };
      autoRotateFrame = requestAnimationFrame(step);
    }

    const pointById = new Map(allPoints.map((p) => [pointKey(p), p]));

    function comboAt(levels) {
      return pointById.get(`${levels.d + 1}-${levels.q + 1}-${levels.c + 1}`);
    }

    function buildEfficientPath() {
      const levels = { d: 0, q: 0, c: 0 };
      const ids = [`1-1-1`];
      const steps = [];
      const purchasePriority = { Damage: 0, Quantity: 1, Chance: 2 };

      while (
        levels.d < damageVals.length - 1 ||
        levels.q < quantityVals.length - 1 ||
        levels.c < chanceVals.length - 1
      ) {
        const current = comboAt(levels);
        const candidates = [];

        if (levels.d < damageVals.length - 1) {
          const next = { d: levels.d + 1, q: levels.q, c: levels.c };
          const cost = damageCosts[next.d];
          const nextCombo = comboAt(next);
          const gain = nextCombo.product - current.product;
          candidates.push({ buy: "Damage", next, cost, gain, efficiency: gain / cost });
        }
        if (levels.q < quantityVals.length - 1) {
          const next = { d: levels.d, q: levels.q + 1, c: levels.c };
          const cost = quantityCosts[next.q];
          const nextCombo = comboAt(next);
          const gain = nextCombo.product - current.product;
          candidates.push({ buy: "Quantity", next, cost, gain, efficiency: gain / cost });
        }
        if (levels.c < chanceVals.length - 1) {
          const next = { d: levels.d, q: levels.q, c: levels.c + 1 };
          const cost = chanceCosts[next.c];
          const nextCombo = comboAt(next);
          const gain = nextCombo.product - current.product;
          candidates.push({ buy: "Chance", next, cost, gain, efficiency: gain / cost });
        }

        candidates.sort((a, b) => {
          if (b.efficiency !== a.efficiency) return b.efficiency - a.efficiency;
          if (b.gain !== a.gain) return b.gain - a.gain;
          if (a.cost !== b.cost) return a.cost - b.cost;
          return purchasePriority[a.buy] - purchasePriority[b.buy];
        });

        const choice = candidates[0];
        levels.d = choice.next.d;
        levels.q = choice.next.q;
        levels.c = choice.next.c;
        const combo = comboAt(levels);
        const id = pointKey(combo);
        ids.push(id);
        steps.push({
          step: steps.length + 1,
          buy: choice.buy,
          upgradeCost: choice.cost,
          gain: choice.gain,
          efficiency: choice.efficiency,
          damageLevel: combo.damageLevel,
          quantityLevel: combo.quantityLevel,
          chanceLevel: combo.chanceLevel,
          damage: combo.damage,
          quantity: combo.quantity,
          chance: combo.chance,
          totalCost: combo.totalCost,
          effectiveDamage: combo.product,
        });
      }

      return { ids, steps };
    }

    const efficientPath = buildEfficientPath();
    const efficientPathSet = new Set(efficientPath.ids);
    const efficientPathStepById = new Map(efficientPath.ids.map((id, idx) => [id, idx]));
    const bestValueIds = new Set(allPoints.filter((p) => p.pareto).map((p) => pointKey(p)));
    const bestValueGlobalCount = bestValueIds.size;

    const globalRanges = {};
    for (const [label, key] of Object.entries(dims)) {
      const vals = allPoints.map((p) => p[key]);
      globalRanges[label] = { min: Math.min(...vals), max: Math.max(...vals) };
    }
    state.costMin = globalRanges["Total Cost"].min;
    state.costMax = globalRanges["Total Cost"].max;
    state.prodMin = globalRanges["Effective Damage"].min;
    state.prodMax = globalRanges["Effective Damage"].max;

    function populateSelect(select, labels, value) {
      select.innerHTML = "";
      for (const label of labels) {
        const opt = document.createElement("option");
        opt.value = label;
        opt.textContent = label;
        if (label === value) opt.selected = true;
        select.appendChild(opt);
      }
    }

    populateSelect(controls.xAxis, Object.keys(dims), state.xAxis);
    populateSelect(controls.yAxis, Object.keys(dims), state.yAxis);
    populateSelect(controls.zAxis, Object.keys(dims), state.zAxis);
    populateSelect(controls.sizeBy, Object.keys(sizeDims), state.sizeBy);
    populateSelect(controls.colorBy, Object.keys(dims), state.colorBy);

    function bindFilterUI() {
      const costMin = globalRanges["Total Cost"].min;
      const costMax = globalRanges["Total Cost"].max;
      controls.costMin.min = costMin;
      controls.costMin.max = costMax;
      controls.costMax.min = costMin;
      controls.costMax.max = costMax;
      controls.costMin.value = state.costMin;
      controls.costMax.value = state.costMax;
      controls.costMinRange.min = costMin;
      controls.costMinRange.max = costMax;
      controls.costMaxRange.min = costMin;
      controls.costMaxRange.max = costMax;
      controls.costMinRange.value = state.costMin;
      controls.costMaxRange.value = state.costMax;

      const prodMin = globalRanges["Effective Damage"].min;
      const prodMax = globalRanges["Effective Damage"].max;
      controls.prodMin.min = prodMin;
      controls.prodMin.max = prodMax;
      controls.prodMax.min = prodMin;
      controls.prodMax.max = prodMax;
      controls.prodMin.value = state.prodMin.toFixed(3);
      controls.prodMax.value = state.prodMax.toFixed(3);
      controls.prodMinRange.min = prodMin;
      controls.prodMinRange.max = prodMax;
      controls.prodMinRange.step = (prodMax - prodMin) / 1000;
      controls.prodMaxRange.min = prodMin;
      controls.prodMaxRange.max = prodMax;
      controls.prodMaxRange.step = (prodMax - prodMin) / 1000;
      controls.prodMinRange.value = state.prodMin;
      controls.prodMaxRange.value = state.prodMax;
    }
    bindFilterUI();
    renderPathPanel();
    try {
      setControlsCollapsed(localStorage.getItem("clx_controls_collapsed") === "1", false);
    } catch (_err) {
      setControlsCollapsed(false, false);
    }

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const headerHeight = plotHeaderEl.getBoundingClientRect().height;
      const mobile = window.matchMedia("(max-width: 1100px)").matches;
      const legendHeight = mobile ? Math.round(clamp(rect.height * 0.24, 92, 130)) : 180;
      const legendTop = Math.round(headerHeight + 10);
      plotWrapEl.style.setProperty("--legend-top", `${legendTop}px`);
      plotWrapEl.style.setProperty("--legend-height", `${legendHeight}px`);
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener("resize", resizeCanvas);

    function clamp(v, lo, hi) {
      return Math.max(lo, Math.min(hi, v));
    }

    function nice(n) {
      if (!isFinite(n)) return "n/a";
      if (Math.abs(n) >= 1000) return n.toFixed(0);
      if (Math.abs(n) >= 10) return n.toFixed(2);
      return n.toFixed(4);
    }

    function renderPathPanel() {
      const finalStep = efficientPath.steps[efficientPath.steps.length - 1];
      const lines = [];
      for (const step of efficientPath.steps) {
        lines.push(
          `${String(step.step).padStart(2, "0")}. Buy ${step.buy.padEnd(8)} | +Cost ${String(step.upgradeCost).padStart(4)} | ` +
          `ED +${nice(step.gain).padStart(8)} | ED/Cost ${nice(step.efficiency).padStart(8)} | ` +
          `D${step.damageLevel} Q${step.quantityLevel} C${step.chanceLevel}`
        );
      }
      pathSteps.textContent = lines.join("\n");
      pathSummary.textContent =
`Path steps: ${efficientPath.steps.length}
Path points: ${efficientPath.ids.length}
Final levels: D${finalStep.damageLevel} Q${finalStep.quantityLevel} C${finalStep.chanceLevel}
Final cost: ${nice(finalStep.totalCost)}
Final Effective Damage: ${nice(finalStep.effectiveDamage)}`;
    }

    function getFiltered() {
      const out = [];
      for (const p of allPoints) {
        if (p.totalCost < state.costMin || p.totalCost > state.costMax) continue;
        if (p.product < state.prodMin || p.product > state.prodMax) continue;
        if (state.onlyPareto && !bestValueIds.has(pointKey(p))) continue;
        out.push(p);
      }
      return out;
    }

    function getActiveRanges(points) {
      if (!points.length) {
        return globalRanges;
      }
      const active = {};
      for (const [label, key] of Object.entries(dims)) {
        const vals = points.map((p) => p[key]);
        active[label] = { min: Math.min(...vals), max: Math.max(...vals) };
      }
      return active;
    }

    function scaleValue(v, min, max) {
      if (Math.abs(max - min) < 1e-12) return 0.5;
      return (v - min) / (max - min);
    }

    function zoomRadiusScale() {
      const baselineZoom = 1.42;
      return clamp(Math.pow(state.zoom / baselineZoom, 0.65), 0.55, 1.85);
    }

    function colorScale(t) {
      // balanced blue -> green -> warm yellow -> orange -> muted red
      const stops = [
        [0.00, [58, 120, 165]],
        [0.25, [150, 201, 165]],
        [0.50, [236, 232, 176]],
        [0.75, [234, 163, 102]],
        [1.00, [201, 78, 76]]
      ];
      const x = clamp(t, 0, 1);
      let i = 0;
      while (i < stops.length - 1 && x > stops[i + 1][0]) i++;
      const [aT, a] = stops[i];
      const [bT, b] = stops[Math.min(i + 1, stops.length - 1)];
      const local = (x - aT) / Math.max(1e-9, (bT - aT));
      const r = Math.round(a[0] + (b[0] - a[0]) * local);
      const g = Math.round(a[1] + (b[1] - a[1]) * local);
      const b2 = Math.round(a[2] + (b[2] - a[2]) * local);
      return `rgb(${r},${g},${b2})`;
    }

    function projectPoint(x, y, z, width, height) {
      const cy = Math.cos(state.yaw), sy = Math.sin(state.yaw);
      const cx = Math.cos(state.pitch), sx = Math.sin(state.pitch);
      const y1 = y * cx - z * sx;
      const z1 = y * sx + z * cx;
      const x2 = x * cy + z1 * sy;
      const z2 = -x * sy + z1 * cy;
      const depth = z2 + 2.8 / state.zoom;
      const f = 430;
      const sx2 = (x2 / depth) * f + width * 0.5 + state.panX;
      const sy2 = (y1 / depth) * f + height * 0.54 + state.panY;
      return { x: sx2, y: sy2, depth };
    }

    function cubeVertices() {
      const v = [];
      for (const x of [-0.5, 0.5]) {
        for (const y of [-0.5, 0.5]) {
          for (const z of [-0.5, 0.5]) {
            v.push([x, y, z]);
          }
        }
      }
      return v;
    }
    const cubeEdges = [
      [0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]
    ];
    const cubeV = cubeVertices();
    let screenPoints = [];

    function edgeLabelForVertices(a, b) {
      const ax = cubeV[a];
      const bx = cubeV[b];
      if (ax[0] !== bx[0]) return state.xAxis;
      if (ax[1] !== bx[1]) return state.yAxis;
      return state.zAxis;
    }

    function drawCube(width, height) {
      const pv = cubeV.map(([x,y,z]) => projectPoint(x,y,z,width,height));
      for (const [a,b] of cubeEdges) {
        const p1 = pv[a];
        const p2 = pv[b];
        if (p1.depth <= 0.05 || p2.depth <= 0.05) continue;

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        if (len < 20) continue;

        const label = `${edgeLabelForVertices(a, b)} `;
        const inset = 4;
        const usableLen = len - inset * 2;
        if (usableLen < 10) continue;

        ctx.save();
        ctx.translate(p1.x, p1.y);
        ctx.rotate(Math.atan2(dy, dx));
        ctx.translate(inset, 0);
        ctx.font = "9px Segoe UI, Arial, sans-serif";
        ctx.fillStyle = "rgba(214, 231, 255, 0.82)";
        ctx.shadowColor = "rgba(8, 18, 32, 0.9)";
        ctx.shadowBlur = 1.4;
        const tokenWidth = Math.max(1, ctx.measureText(label).width);
        ctx.beginPath();
        ctx.rect(0, -8, usableLen, 14);
        ctx.clip();
        const repeat = Math.ceil(usableLen / tokenWidth) + 1;
        for (let i = 0; i < repeat; i++) {
          ctx.fillText(label, i * tokenWidth, 0);
        }
        ctx.restore();
      }

      for (const p of pv) {
        if (p.depth <= 0.05) continue;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3.2, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(92, 105, 122, 0.58)";
        ctx.fill();
        ctx.strokeStyle = "rgba(214, 222, 233, 0.9)";
        ctx.lineWidth = 0.8;
        ctx.stroke();
      }
    }

    function drawTag(x, y, text, borderColor, fillColor = "rgba(255,255,255,0.88)") {
      ctx.save();
      ctx.font = "12px Segoe UI, Arial, sans-serif";
      const padX = 5;
      const padY = 3;
      const width = ctx.measureText(text).width + padX * 2;
      const height = 18;
      const bx = x + 6;
      const by = y - height * 0.5;
      ctx.fillStyle = fillColor;
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.rect(bx, by, width, height);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "#0f1b2d";
      ctx.fillText(text, bx + padX, by + height - padY - 2);
      ctx.restore();
    }

    function drawAxisGuides(width, height) {
      const axes = [
        { key: "x", label: `X: ${state.xAxis}`, color: "rgba(213, 61, 61, 0.95)", end: [0.62, 0, 0], neg: [-0.58, 0, 0], pos: [0.58, 0, 0] },
        { key: "y", label: `Y: ${state.yAxis}`, color: "rgba(56, 146, 76, 0.95)", end: [0, 0.62, 0], neg: [0, -0.58, 0], pos: [0, 0.58, 0] },
        { key: "z", label: `Z: ${state.zAxis}`, color: "rgba(44, 104, 201, 0.95)", end: [0, 0, 0.62], neg: [0, 0, -0.58], pos: [0, 0, 0.58] }
      ];
      const center = projectPoint(0, 0, 0, width, height);

      for (const a of axes) {
        const end = projectPoint(a.end[0], a.end[1], a.end[2], width, height);
        const neg = projectPoint(a.neg[0], a.neg[1], a.neg[2], width, height);
        const pos = projectPoint(a.pos[0], a.pos[1], a.pos[2], width, height);
        if (![center.depth, end.depth, neg.depth, pos.depth].every((d) => d > 0.05)) continue;

        ctx.save();
        ctx.strokeStyle = a.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();

        // Arrow head
        const vx = end.x - center.x;
        const vy = end.y - center.y;
        const mag = Math.hypot(vx, vy) || 1;
        const ux = vx / mag;
        const uy = vy / mag;
        const ah = 9;
        ctx.beginPath();
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(end.x - ux * ah - uy * (ah * 0.5), end.y - uy * ah + ux * (ah * 0.5));
        ctx.lineTo(end.x - ux * ah + uy * (ah * 0.5), end.y - uy * ah - ux * (ah * 0.5));
        ctx.closePath();
        ctx.fillStyle = a.color;
        ctx.fill();
        ctx.restore();

        drawTag(end.x, end.y, a.label, a.color);
      }
    }

    function drawEfficientPath(projectedById) {
      if (!state.showPathLine && !state.showPathPoints) return;

      const visiblePathNodes = [];
      for (const id of efficientPath.ids) {
        const node = projectedById.get(id);
        if (node && node.depth > 0.08) visiblePathNodes.push(node);
      }

      if (state.showPathLine && visiblePathNodes.length >= 2) {
        ctx.save();
        ctx.strokeStyle = "rgba(15, 118, 110, 0.95)";
        ctx.lineWidth = 2.4;
        ctx.setLineDash([8, 5]);
        ctx.beginPath();
        ctx.moveTo(visiblePathNodes[0].x, visiblePathNodes[0].y);
        for (let i = 1; i < visiblePathNodes.length; i++) {
          ctx.lineTo(visiblePathNodes[i].x, visiblePathNodes[i].y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }

      if (state.showPathPoints) {
        for (const node of visiblePathNodes) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, Math.max(2.4, node.radius * 0.42), 0, Math.PI * 2);
          ctx.fillStyle = "rgba(15, 118, 110, 0.96)";
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.95)";
          ctx.lineWidth = 0.9;
          ctx.stroke();
        }
      }
    }

    function draw() {
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      ctx.clearRect(0, 0, w, h);
      drawCube(w, h);

      const points = getFiltered();
      const activeRanges = getActiveRanges(points);
      countLabel.textContent = `${points.length} / ${allPoints.length} points`;

      // Keep spatial positions fixed regardless of filtering.
      const xr = globalRanges[state.xAxis];
      const yr = globalRanges[state.yAxis];
      const zr = globalRanges[state.zAxis];
      // Re-scale visual encoding to visible subset.
      const cr = activeRanges[state.colorBy];
      const sr = state.sizeBy === "Constant" ? {min: 0, max: 1} : activeRanges[state.sizeBy];
      const radiusZoomScale = zoomRadiusScale();

      legendName.textContent = state.colorBy;
      legendTop.textContent = nice(cr.max);
      legendBottom.textContent = nice(cr.min);

      const projected = [];
      for (const p of points) {
        const xVal = p[dims[state.xAxis]];
        const yVal = p[dims[state.yAxis]];
        const zVal = p[dims[state.zAxis]];
        const xn = scaleValue(xVal, xr.min, xr.max) - 0.5;
        const yn = scaleValue(yVal, yr.min, yr.max) - 0.5;
        const zn = scaleValue(zVal, zr.min, zr.max) - 0.5;
        const pos = projectPoint(xn, yn, zn, w, h);

        const cVal = p[dims[state.colorBy]];
        const cNorm = scaleValue(cVal, cr.min, cr.max);
        const fill = colorScale(cNorm);

        let radius = 4.2;
        if (state.sizeBy !== "Constant") {
          const sVal = p[dims[state.sizeBy]];
          const sNorm = scaleValue(sVal, sr.min, sr.max);
          radius = 2.4 + sNorm * 13.5;
        }
        radius *= radiusZoomScale;

        projected.push({
          p, x: pos.x, y: pos.y, depth: pos.depth,
          radius, fill, pareto: p.pareto, id: pointKey(p)
        });
      }

      projected.sort((a,b) => b.depth - a.depth);
      screenPoints = projected;
      const projectedById = new Map(projected.map((d) => [d.id, d]));

      for (const d of projected) {
        if (d.depth <= 0.08) continue;
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.radius, 0, Math.PI * 2);
        ctx.fillStyle = d.fill;
        ctx.globalAlpha = 0.80;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(8, 20, 34, 0.35)";
        ctx.lineWidth = 0.8;
        ctx.stroke();

        if (state.showPareto && !state.onlyPareto && bestValueIds.has(d.id)) {
          ctx.beginPath();
          ctx.arc(d.x, d.y, d.radius + 1.8, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(210, 32, 59, 0.95)";
          ctx.lineWidth = 1.2;
          ctx.stroke();
        }

        if (state.selectedA === d.id || state.selectedB === d.id) {
          const isA = state.selectedA === d.id;
          const ringColor = isA ? "rgba(249, 115, 22, 0.98)" : "rgba(124, 58, 237, 0.98)";
          ctx.beginPath();
          ctx.arc(d.x, d.y, d.radius + 4.2, 0, Math.PI * 2);
          ctx.strokeStyle = ringColor;
          ctx.lineWidth = 2.6;
          ctx.stroke();
          drawTag(d.x + d.radius + 3, d.y - d.radius - 3, isA ? "A" : "B", ringColor, "rgba(255,255,255,0.94)");
        }
      }

      drawEfficientPath(projectedById);
      updateStats(points);
      updateCompareStats(points);
      updatePathVisibility(points);
    }

    function updateStats(points) {
      if (!points.length) {
        stats.textContent = "No points in current filter.";
        return;
      }
      let minCost = Infinity, maxCost = -Infinity;
      let minEffectiveDamage = Infinity, maxEffectiveDamage = -Infinity;
      let best = points[0];
      for (const p of points) {
        if (p.totalCost < minCost) minCost = p.totalCost;
        if (p.totalCost > maxCost) maxCost = p.totalCost;
        if (p.product < minEffectiveDamage) minEffectiveDamage = p.product;
        if (p.product > maxEffectiveDamage) {
          maxEffectiveDamage = p.product;
          best = p;
        }
      }
      const visibleBestValueCount = points.filter((p) => bestValueIds.has(pointKey(p))).length;
      stats.textContent =
`Visible points: ${points.length}
Global Best Value points: ${bestValueGlobalCount}
Visible Best Value points: ${visibleBestValueCount}
Cost range: ${nice(minCost)} to ${nice(maxCost)}
Effective Damage range: ${nice(minEffectiveDamage)} to ${nice(maxEffectiveDamage)}
Best visible Effective Damage:
  Damage ${best.damage}, Quantity ${best.quantity}, Chance ${best.chance}%
  Cost ${nice(best.totalCost)}, Effective Damage ${nice(best.product)}`;
    }

    function updatePathVisibility(points) {
      const visibleIds = new Set(points.map((p) => pointKey(p)));
      let visiblePathPoints = 0;
      for (const id of efficientPath.ids) {
        if (visibleIds.has(id)) visiblePathPoints++;
      }
      const finalStep = efficientPath.steps[efficientPath.steps.length - 1];
      pathSummary.textContent =
`Path steps: ${efficientPath.steps.length}
Path points: ${efficientPath.ids.length}
Visible path points: ${visiblePathPoints}/${efficientPath.ids.length}
Final levels: D${finalStep.damageLevel} Q${finalStep.quantityLevel} C${finalStep.chanceLevel}
Final cost: ${nice(finalStep.totalCost)}
Final Effective Damage: ${nice(finalStep.effectiveDamage)}`;
    }

    function updateCompareStats(points) {
      const idSet = new Set(points.map((p) => pointKey(p)));
      const a = state.selectedA ? pointById.get(state.selectedA) : null;
      const b = state.selectedB ? pointById.get(state.selectedB) : null;

      if (!a && !b) {
        compareStats.textContent = "Select point A, then point B.";
        return;
      }

      const describe = (name, p) => {
        if (!p) return `${name}: (not selected)`;
        const visible = idSet.has(pointKey(p)) ? "visible" : "filtered out";
        const step = efficientPathStepById.get(pointKey(p));
        return `${name}: D${p.damageLevel} Q${p.quantityLevel} C${p.chanceLevel}
  Damage ${p.damage}, Quantity ${p.quantity}, Chance ${p.chance}%
  Cost ${nice(p.totalCost)}, Effective Damage ${nice(p.product)}
  Best Value ${p.pareto ? "Yes" : "No"} (${visible})
  Efficient Path step ${step === undefined ? "No" : step}`;
      };

      if (!a || !b) {
        compareStats.textContent = `${describe("A", a)}
${describe("B", b)}

Select another point to complete the comparison.`;
        return;
      }

      const dDamage = b.damage - a.damage;
      const dQuantity = b.quantity - a.quantity;
      const dChance = b.chance - a.chance;
      const dCost = b.totalCost - a.totalCost;
      const dEffectiveDamage = b.product - a.product;

      compareStats.textContent = `${describe("A", a)}
${describe("B", b)}

Delta (B - A):
  Damage ${nice(dDamage)}, Quantity ${nice(dQuantity)}, Chance ${nice(dChance)}
  Cost ${nice(dCost)}, Effective Damage ${nice(dEffectiveDamage)}`;
    }

    function findPointAt(mx, my) {
      for (let i = screenPoints.length - 1; i >= 0; i--) {
        const s = screenPoints[i];
        const dx = mx - s.x;
        const dy = my - s.y;
        if (dx * dx + dy * dy <= (s.radius + 2) * (s.radius + 2)) {
          return s;
        }
      }
      return null;
    }

    function selectPoint(id) {
      if (state.selectedA === id) {
        state.selectedA = null;
        return;
      }
      if (state.selectedB === id) {
        state.selectedB = null;
        return;
      }
      if (!state.selectedA) {
        state.selectedA = id;
        return;
      }
      if (!state.selectedB) {
        state.selectedB = id;
        return;
      }
      state.selectedA = state.selectedB;
      state.selectedB = id;
    }

    function updateFromControls() {
      state.xAxis = controls.xAxis.value;
      state.yAxis = controls.yAxis.value;
      state.zAxis = controls.zAxis.value;
      state.sizeBy = controls.sizeBy.value;
      state.colorBy = controls.colorBy.value;
      state.showPareto = controls.showPareto.checked;
      state.onlyPareto = controls.onlyPareto.checked;
      state.showPathLine = controls.showPathLine.checked;
      state.showPathPoints = controls.showPathPoints.checked;
      draw();
    }

    function syncRangePairs() {
      const cMinGlobal = globalRanges["Total Cost"].min;
      const cMaxGlobal = globalRanges["Total Cost"].max;
      state.costMin = clamp(state.costMin, cMinGlobal, state.costMax);
      state.costMax = clamp(state.costMax, state.costMin, cMaxGlobal);
      controls.costMin.value = Math.round(state.costMin);
      controls.costMax.value = Math.round(state.costMax);
      controls.costMinRange.value = state.costMin;
      controls.costMaxRange.value = state.costMax;

      const pMinGlobal = globalRanges["Effective Damage"].min;
      const pMaxGlobal = globalRanges["Effective Damage"].max;
      state.prodMin = clamp(state.prodMin, pMinGlobal, state.prodMax);
      state.prodMax = clamp(state.prodMax, state.prodMin, pMaxGlobal);
      controls.prodMin.value = state.prodMin.toFixed(3);
      controls.prodMax.value = state.prodMax.toFixed(3);
      controls.prodMinRange.value = state.prodMin;
      controls.prodMaxRange.value = state.prodMax;
    }

    controls.xAxis.addEventListener("change", updateFromControls);
    controls.yAxis.addEventListener("change", updateFromControls);
    controls.zAxis.addEventListener("change", updateFromControls);
    controls.sizeBy.addEventListener("change", updateFromControls);
    controls.colorBy.addEventListener("change", updateFromControls);
    controls.showPareto.addEventListener("change", updateFromControls);
    controls.onlyPareto.addEventListener("change", updateFromControls);
    controls.toggleControls.addEventListener("click", () => {
      setControlsCollapsed(!state.controlsCollapsed);
    });
    controls.showPathLine.addEventListener("change", updateFromControls);
    controls.showPathPoints.addEventListener("change", updateFromControls);

    controls.costMin.addEventListener("input", (e) => {
      state.costMin = Number(e.target.value);
      syncRangePairs();
      draw();
    });
    controls.costMax.addEventListener("input", (e) => {
      state.costMax = Number(e.target.value);
      syncRangePairs();
      draw();
    });
    controls.costMinRange.addEventListener("input", (e) => {
      state.costMin = Number(e.target.value);
      if (state.costMin > state.costMax) state.costMax = state.costMin;
      syncRangePairs();
      draw();
    });
    controls.costMaxRange.addEventListener("input", (e) => {
      state.costMax = Number(e.target.value);
      if (state.costMax < state.costMin) state.costMin = state.costMax;
      syncRangePairs();
      draw();
    });
    controls.prodMin.addEventListener("input", (e) => {
      state.prodMin = Number(e.target.value);
      syncRangePairs();
      draw();
    });
    controls.prodMax.addEventListener("input", (e) => {
      state.prodMax = Number(e.target.value);
      syncRangePairs();
      draw();
    });
    controls.prodMinRange.addEventListener("input", (e) => {
      state.prodMin = Number(e.target.value);
      if (state.prodMin > state.prodMax) state.prodMax = state.prodMin;
      syncRangePairs();
      draw();
    });
    controls.prodMaxRange.addEventListener("input", (e) => {
      state.prodMax = Number(e.target.value);
      if (state.prodMax < state.prodMin) state.prodMin = state.prodMax;
      syncRangePairs();
      draw();
    });

    controls.resetFilters.addEventListener("click", () => {
      state.costMin = globalRanges["Total Cost"].min;
      state.costMax = globalRanges["Total Cost"].max;
      state.prodMin = globalRanges["Effective Damage"].min;
      state.prodMax = globalRanges["Effective Damage"].max;
      state.onlyPareto = false;
      controls.onlyPareto.checked = false;
      syncRangePairs();
      draw();
    });

    controls.resetView.addEventListener("click", () => {
      stopAutoRotate();
      state.yaw = -0.74;
      state.pitch = 0.42;
      state.zoom = 1.42;
      state.panX = 0;
      state.panY = 0;
      draw();
    });
    controls.clearCompare.addEventListener("click", () => {
      state.selectedA = null;
      state.selectedB = null;
      draw();
    });
    controls.swapCompare.addEventListener("click", () => {
      const tmp = state.selectedA;
      state.selectedA = state.selectedB;
      state.selectedB = tmp;
      draw();
    });

    let dragging = false;
    let dragMoved = false;
    let lastX = 0, lastY = 0;
    let panMode = false;
    let touchMode = null;
    let touchMoved = false;
    let pinchStartDistance = 0;
    let pinchStartZoom = state.zoom;
    let pinchStartMidX = 0;
    let pinchStartMidY = 0;
    let pinchStartPanX = 0;
    let pinchStartPanY = 0;
    let touchTapClientX = 0;
    let touchTapClientY = 0;

    function getTouchDistance(t0, t1) {
      return Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
    }

    function getTouchMidpoint(t0, t1) {
      return {
        x: (t0.clientX + t1.clientX) * 0.5,
        y: (t0.clientY + t1.clientY) * 0.5
      };
    }

    function handlePointSelectionAtClient(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const mx = clientX - rect.left;
      const my = clientY - rect.top;
      const found = findPointAt(mx, my);
      if (!found) return;
      selectPoint(found.id);
      draw();
    }

    canvas.addEventListener("mousedown", (e) => {
      stopAutoRotate();
      dragging = true;
      dragMoved = false;
      lastX = e.clientX;
      lastY = e.clientY;
      panMode = e.shiftKey || e.button === 1;
      canvas.classList.add("dragging");
    });
    window.addEventListener("mouseup", () => {
      dragging = false;
      canvas.classList.remove("dragging");
    });
    window.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (dragging) {
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        if (Math.abs(dx) + Math.abs(dy) > 1) dragMoved = true;
        lastX = e.clientX;
        lastY = e.clientY;
        if (panMode) {
          state.panX += dx;
          state.panY += dy;
        } else {
          state.yaw += dx * 0.008;
          state.pitch += dy * 0.008;
        }
        draw();
      }

      const found = findPointAt(mx, my);
      if (!found) {
        tooltip.style.display = "none";
        return;
      }
      tooltip.style.display = "block";
      tooltip.style.left = `${Math.min(mx + 18, rect.width - 210)}px`;
      tooltip.style.top = `${Math.max(my - 16, 10)}px`;
      const pathStep = efficientPathStepById.has(found.id) ? efficientPathStepById.get(found.id) : null;
      tooltip.innerHTML =
`<strong>Damage ${found.p.damage}, Quantity ${found.p.quantity}, Chance ${found.p.chance}%</strong><br>
Cost: ${nice(found.p.totalCost)}<br>
Effective Damage: ${nice(found.p.product)}<br>
Levels: D${found.p.damageLevel} Q${found.p.quantityLevel} C${found.p.chanceLevel}<br>
Best Value: ${found.p.pareto ? "Yes" : "No"}<br>
Efficient Path Step: ${pathStep === null ? "No" : pathStep}`;
    });
    canvas.addEventListener("click", (e) => {
      if (dragMoved) return;
      handlePointSelectionAtClient(e.clientX, e.clientY);
    });

    canvas.addEventListener("wheel", (e) => {
      stopAutoRotate();
      e.preventDefault();
      state.zoom *= e.deltaY < 0 ? 1.08 : 0.92;
      state.zoom = clamp(state.zoom, 0.55, 3.7);
      draw();
    }, { passive: false });

    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    canvas.addEventListener("touchstart", (e) => {
      stopAutoRotate();
      if (e.touches.length === 1) {
        const t = e.touches[0];
        touchMode = "rotate";
        touchMoved = false;
        lastX = t.clientX;
        lastY = t.clientY;
        touchTapClientX = t.clientX;
        touchTapClientY = t.clientY;
        canvas.classList.add("dragging");
      } else if (e.touches.length >= 2) {
        const t0 = e.touches[0];
        const t1 = e.touches[1];
        const mid = getTouchMidpoint(t0, t1);
        touchMode = "pinch-pan";
        touchMoved = true;
        pinchStartDistance = Math.max(1, getTouchDistance(t0, t1));
        pinchStartZoom = state.zoom;
        pinchStartMidX = mid.x;
        pinchStartMidY = mid.y;
        pinchStartPanX = state.panX;
        pinchStartPanY = state.panY;
        canvas.classList.add("dragging");
      }
      tooltip.style.display = "none";
    }, { passive: true });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1 && touchMode === "rotate") {
        e.preventDefault();
        const t = e.touches[0];
        const dx = t.clientX - lastX;
        const dy = t.clientY - lastY;
        if (Math.abs(dx) + Math.abs(dy) > 1) touchMoved = true;
        lastX = t.clientX;
        lastY = t.clientY;
        state.yaw += dx * 0.008;
        state.pitch += dy * 0.008;
        draw();
        return;
      }

      if (e.touches.length >= 2) {
        e.preventDefault();
        const t0 = e.touches[0];
        const t1 = e.touches[1];
        const mid = getTouchMidpoint(t0, t1);
        const dist = Math.max(1, getTouchDistance(t0, t1));

        if (touchMode !== "pinch-pan") {
          touchMode = "pinch-pan";
          touchMoved = true;
          pinchStartDistance = dist;
          pinchStartZoom = state.zoom;
          pinchStartMidX = mid.x;
          pinchStartMidY = mid.y;
          pinchStartPanX = state.panX;
          pinchStartPanY = state.panY;
        }

        const zoomFactor = dist / pinchStartDistance;
        state.zoom = clamp(pinchStartZoom * zoomFactor, 0.55, 3.7);
        state.panX = pinchStartPanX + (mid.x - pinchStartMidX);
        state.panY = pinchStartPanY + (mid.y - pinchStartMidY);
        draw();
      }
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      if (touchMode === "rotate" && !touchMoved && e.touches.length === 0) {
        handlePointSelectionAtClient(touchTapClientX, touchTapClientY);
      }

      if (e.touches.length === 0) {
        touchMode = null;
        touchMoved = false;
        canvas.classList.remove("dragging");
        return;
      }

      if (e.touches.length === 1) {
        const t = e.touches[0];
        touchMode = "rotate";
        touchMoved = true;
        lastX = t.clientX;
        lastY = t.clientY;
        touchTapClientX = t.clientX;
        touchTapClientY = t.clientY;
      }
    }, { passive: true });

    canvas.addEventListener("touchcancel", () => {
      touchMode = null;
      touchMoved = false;
      canvas.classList.remove("dragging");
      tooltip.style.display = "none";
    }, { passive: true });

    syncRangePairs();
    resizeCanvas();
    startAutoRotate();
  </script>
</body>
</html>
